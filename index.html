<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SwipeTree — Family Navigator</title>
  <style>
*{box-sizing:border-box;-webkit-tap-highlight-color: transparent;}
html,body{margin:0;padding:0;background:#000;color:#fff;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  -webkit-touch-callout:none; user-select:none; -webkit-user-select:none;}
img{-webkit-touch-callout:none}
#app{display:flex;flex-direction:column;height:100%;}

.topbar{display:flex;align-items:center;gap:.75rem;padding:.5rem .75rem;background:#111;border-bottom:1px solid #222;position:sticky;top:0;z-index:5}
.brand{font-weight:700;letter-spacing:.3px;font-size:1rem;opacity:.9}
.spacer{flex:1}
.btn{background:#1f1f1f;border:1px solid #333;color:#fff;padding:.45rem .8rem;border-radius:.75rem;cursor:pointer}
.btn.subtle{background:#0e0e0e}
.btn:active{transform:scale(.98)}

/* Navigation Controls */
.nav-controls{display:flex;justify-content:center;gap:.5rem;padding:.75rem;background:#0a0a0a;border-bottom:1px solid #222;}
.nav-btn{background:#1a1a1a;border:1px solid #333;color:#fff;padding:.6rem 1rem;border-radius:8px;cursor:pointer;font-size:.9rem;font-weight:500;transition:all .2s ease;}
.nav-btn:hover{background:#2a2a2a;border-color:#444;}
.nav-btn:active{transform:scale(.95);background:#333;}
.nav-btn.active{background:#0066cc;border-color:#0066cc;color:#fff;}

/* ENHANCED: Responsive Stage Layout */
#stage{
  position:relative;
  flex:1;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:clamp(.5rem, 2vw, 1.5rem);
  min-height:0;
}

/* ENHANCED: Responsive Anchor Wrap */
#anchorWrap{
  position:relative;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:clamp(.25rem, 1vw, .75rem);
  width:100%;
  max-width:100%;
  height:100%;
}

/* ENHANCED: Dynamic Image Sizing */
#anchorImg{
  width:100%;
  height:100%;
  max-width:min(85vw, 600px);
  max-height:min(75vh, 600px);
  object-fit:contain;
  border-radius:clamp(12px, 2vw, 20px);
  box-shadow:0 10px 40px rgba(0,0,0,.6);
  border:1px solid #222;
}

/* ENHANCED: Responsive Text */
.name{
  font-size:clamp(1rem, 2.5vw, 1.3rem);
  opacity:.95;
  min-height:1.3em;
  text-align:center;
  max-width:90vw;
  word-wrap:break-word;
}

.details{
  font-size:clamp(.8rem, 2vw, 1rem);
  opacity:.75;
  text-align:center;
  margin-top:.25rem;
  max-width:85vw;
  word-wrap:break-word;
}

.details .date{color:#7aa8ff}
.details .location{color:#90ee90}
.details .notes{font-style:italic;margin-top:.25rem;opacity:.6}

/* ENHANCED: Responsive Grid Overlay */
#gridOverlay{
  position:absolute;
  inset:0;
  background:#000;
  display:flex;
  flex-direction:column;
  z-index:4;
  align-items:center;
}
#gridOverlay.hidden{display:none}

.gridHeader{
  padding:clamp(.5rem, 2vw, 1rem);
  border-bottom:1px solid #222;
  width:100%;
  max-width:1200px;
  text-align:center;
}

.gridHeader h2{
  margin:0;
  font-size:clamp(1.1rem, 3vw, 1.5rem);
}

/* ENHANCED: Responsive Grid Layouts */
.grid{
  display:grid;
  gap:clamp(.5rem, 1.5vw, 1rem);
  padding:clamp(.75rem, 2vw, 1.5rem);
  width:100%;
  max-width:1200px;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  justify-content:center;
  grid-template-columns:repeat(auto-fit, minmax(min(120px, 25vw), 1fr));
}

/* ENHANCED: Parents Grid - Optimized for 2 people */
.grid.parents{
  grid-template-columns:repeat(auto-fit, minmax(min(180px, 40vw), 1fr));
  max-width:800px;
  justify-content:center;
  gap:clamp(.75rem, 3vw, 2rem);
}

/* ENHANCED: Children Grid - Optimized for up to 9 children */
.grid.children{
  grid-template-columns:repeat(auto-fit, minmax(min(110px, 28vw), 1fr));
  max-width:1000px;
  justify-content:center;
  gap:clamp(.5rem, 1.2vw, .8rem);
}

/* Children grid specific layouts for different screen sizes */
@media (min-width: 768px) {
  .grid.children{
    grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
    gap:clamp(.75rem, 1.5vw, 1rem);
  }
}

@media (min-width: 1024px) {
  .grid.children{
    grid-template-columns:repeat(auto-fit, minmax(160px, 180px));
    gap:1rem;
    max-width:1100px;
  }
}

/* ENHANCED: Responsive Grid Tiles */
.tile{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:clamp(.25rem, 1vw, .5rem);
  background:#0b0b0b;
  border:1px solid #222;
  border-radius:clamp(10px, 2vw, 16px);
  padding:clamp(.5rem, 1.5vw, .8rem);
  cursor:pointer;
  transition:transform .2s ease;
}

.tile:active{transform:scale(.98)}

/* ENHANCED: Responsive Tile Images */
.tile img{
  width:100%;
  height:clamp(20vh, 25vh, 30vh);
  object-fit:contain;
  background:#000;
  border-radius:clamp(6px, 1.5vw, 12px);
  border:1px solid #333;
}

/* ENHANCED: Responsive Tile Text */
.tile .label{
  font-size:clamp(.85rem, 2vw, 1rem);
  opacity:.95;
  min-height:1.2em;
  text-align:center;
  word-wrap:break-word;
  max-width:100%;
}

.tile .tile-details{
  font-size:clamp(.75rem, 1.8vw, .9rem);
  opacity:.7;
  text-align:center;
  margin-top:.25rem;
  word-wrap:break-word;
  max-width:100%;
}

.highlight{outline:3px solid #7aa8ff;outline-offset:2px}
.noselect{user-select:none;-webkit-user-select:none;-ms-user-select:none}

/* ENHANCED: Responsive Edit Overlay */
.editOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:10;
  padding:clamp(.5rem, 2vw, 1rem);
}
.editOverlay.hidden{display:none}

.editCard{
  background:#111;
  border:1px solid #333;
  border-radius:clamp(12px, 2vw, 20px);
  padding:clamp(1rem, 3vw, 1.5rem);
  min-width:min(90vw, 420px);
  max-width:90vw;
  box-shadow:0 10px 40px rgba(0,0,0,.6);
}

.editRow{
  display:flex;
  flex-direction:column;
  gap:.35rem;
  margin-bottom:.75rem;
}

.editRow label{
  font-size:clamp(.85rem, 2vw, .95rem);
  opacity:.85;
}

.editRow input{
  background:#0a0a0a;
  border:1px solid #333;
  color:#fff;
  padding:clamp(.45rem, 1.5vw, .65rem);
  border-radius:.6rem;
  font-size:clamp(.9rem, 2vw, 1rem);
}

.editActions{
  display:flex;
  justify-content:flex-end;
  gap:.5rem;
  margin-top:.5rem;
}

/* ENHANCED: Mobile Optimizations */
@media (max-width: 480px) {
  .nav-controls{
    gap:.25rem;
    padding:.5rem;
  }
  
  .nav-btn{
    padding:.5rem .75rem;
    font-size:.85rem;
  }
  
  #anchorImg{
    max-height:60vh;
  }
  
  .grid{
    grid-template-columns:repeat(auto-fit, minmax(100px, 1fr));
  }
  
  .grid.parents{
    grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
  }
  
  .grid.children{
    grid-template-columns:repeat(auto-fit, minmax(95px, 1fr));
    gap:.4rem;
  }
  
  .tile img{
    height:18vh;
  }
}

/* ENHANCED: Large Screen Optimizations */
@media (min-width: 1200px) {
  .grid{
    grid-template-columns:repeat(auto-fit, minmax(160px, 200px));
    gap:1.5rem;
  }
  
  .grid.parents{
    grid-template-columns:repeat(2, minmax(220px, 300px));
    gap:3rem;
  }
  
  .grid.children{
    grid-template-columns:repeat(auto-fit, minmax(180px, 200px));
    gap:1.2rem;
    max-width:1200px;
  }
  
  .tile img{
    height:28vh;
  }
  
  #anchorImg{
    max-width:700px;
    max-height:80vh;
  }
}

/* ENHANCED: Landscape Mobile Optimizations */
@media (max-height: 500px) and (orientation: landscape) {
  #anchorImg{
    max-height:70vh;
  }
  
  .tile img{
    height:25vh;
  }
  
  .nav-controls{
    padding:.5rem;
  }
}
  </style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <div class="brand">SwipeTree</div>
      <div class="spacer"></div>
      <button id="backBtn" class="btn subtle">← Back</button>
    </div>
    
    <!-- Navigation Controls -->
    <div class="nav-controls">
      <button class="nav-btn" id="navParents">PARENTS</button>
      <button class="nav-btn" id="navPartner">PARTNER</button>
      <button class="nav-btn" id="navSiblings">SIBLINGS</button>
      <button class="nav-btn" id="navChildren">CHILDREN</button>
    </div>
    
    <div id="stage">
      <div id="anchorWrap">
        <img id="anchorImg" alt="Family Member" class="noselect">
        <div id="anchorName" class="name"></div>
        <div id="anchorDetails" class="details"></div>
      </div>
      
      <div id="gridOverlay" class="hidden">
        <div class="gridHeader">
          <h2 id="gridTitle">Navigation</h2>
        </div>
        <div id="grid" class="grid"></div>
      </div>
    </div>
  </div>

  <div id="editOverlay" class="editOverlay hidden">
    <div class="editCard">
      <div class="editRow">
        <label>Name</label>
        <input id="editName" type="text" placeholder="Enter name">
      </div>
      <div class="editRow">
        <label>Date of Birth</label>
        <input id="editDob" type="text" placeholder="e.g., 1990-01-15">
      </div>
      <div class="editRow">
        <label>Location</label>
        <input id="editLocation" type="text" placeholder="City, State">
      </div>
      <div class="editRow">
        <label>Notes</label>
        <input id="editNotes" type="text" placeholder="Additional details">
      </div>
      <div class="editActions">
        <button id="editCancel" class="btn">Cancel</button>
        <button id="editSave" class="btn">Save</button>
      </div>
    </div>
  </div>

  <script>
// SwipeTree with Enhanced Partner System: spouse_link.json + .1 spouses + .0 co-parents
(function(){
  'use strict';
  
  const params = new URLSearchParams(location.search);
  const DEFAULT_IMG_BASE = 'https://allofusbhere.github.io/family-tree-images/';
  const IMG_BASE = (params.get('imgbase') || DEFAULT_IMG_BASE).replace(/\/?$/, '/');
  const IMG_EXT = '.jpg';
  const PLACEHOLDER_NAME = 'placeholder.jpg';
  const PLACEHOLDER = IMG_BASE + PLACEHOLDER_NAME;
  const MAX_CANDIDATES = 9, SWIPE_THRESHOLD = 40, LONGPRESS_MS = 520;

  const state = { 
    anchorId: null, 
    historyStack: [], 
    gridOpen: false, 
    gridType: null, 
    touchStart: null, 
    longPressTimer: null,
    namesMap: {},
    familyLabels: {},
    lastLabelsCheck: 0,
    spouseMap: {},
    lastSpouseCheck: 0
  };

  const anchorImg = document.getElementById('anchorImg');
  const anchorWrap = document.getElementById('anchorWrap');
  const anchorName = document.getElementById('anchorName');
  const anchorDetails = document.getElementById('anchorDetails');
  const gridOverlay = document.getElementById('gridOverlay');
  const grid = document.getElementById('grid');
  const gridTitle = document.getElementById('gridTitle');
  const backBtn = document.getElementById('backBtn');
  const editOverlay = document.getElementById('editOverlay');
  const editName = document.getElementById('editName');
  const editDob = document.getElementById('editDob');
  const editLocation = document.getElementById('editLocation');
  const editNotes = document.getElementById('editNotes');
  const editCancel = document.getElementById('editCancel');
  const editSave = document.getElementById('editSave');

  // Navigation button elements
  const navParents = document.getElementById('navParents');
  const navPartner = document.getElementById('navPartner');
  const navSiblings = document.getElementById('navSiblings');
  const navChildren = document.getElementById('navChildren');

  function idToSrc(id){ return IMG_BASE + id + IMG_EXT; }
  function exists(src){ 
    return new Promise(resolve => { 
      const img = new Image(); 
      img.onload = () => resolve(true); 
      img.onerror = () => resolve(false);
      img.src = src; // Removed cache busting - back to simple approach
    }); 
  }
  const cacheBust = ()=> `?v=${Date.now()%1e7}`;
  function setURLHash(id){ try{ history.replaceState(null,'',`#${encodeURIComponent(id)}`); }catch{} }

  // Load spouse links from GitHub
  async function loadSpouseMap() {
    const now = Date.now();
    const CACHE_TIME = 30000; // 30 seconds cache time
    
    // Use cache if recent
    if (state.spouseMap && (now - state.lastSpouseCheck) < CACHE_TIME) {
      return state.spouseMap;
    }
    
    try {
      const response = await fetch(`https://raw.githubusercontent.com/allofusbhere/swipe-tree-labels/main/spouse_link.json?t=${now}`, {
        cache: 'no-store'
      });
      
      if (response.ok) {
        const data = await response.json();
        // Convert array format to map for faster lookup
        const map = {};
        if (Array.isArray(data)) {
          data.forEach(pair => {
            if (pair.length === 2) {
              map[pair[0]] = pair[1];
              map[pair[1]] = pair[0];
            }
          });
        }
        state.spouseMap = map;
        state.lastSpouseCheck = now;
        console.log('Loaded spouse links:', Object.keys(state.spouseMap).length / 2, 'pairs');
        return state.spouseMap;
      } else {
        console.warn('Could not load spouse_link.json, using existing cache');
        return state.spouseMap || {};
      }
    } catch (error) {
      console.warn('Error loading spouse links:', error);
      return state.spouseMap || {};
    }
  }

  // Load family labels from GitHub
  async function loadFamilyLabels() {
    const now = Date.now();
    const CACHE_TIME = 30000; // 30 seconds cache time
    
    // Use cache if recent
    if (state.familyLabels && (now - state.lastLabelsCheck) < CACHE_TIME) {
      return state.familyLabels;
    }
    
    try {
      const response = await fetch(`https://raw.githubusercontent.com/allofusbhere/swipe-tree-labels/main/family_labels.json?t=${now}`, {
        cache: 'no-store'
      });
      
      if (response.ok) {
        const data = await response.json();
        state.familyLabels = data || {};
        state.lastLabelsCheck = now;
        console.log('Loaded family labels from GitHub:', Object.keys(state.familyLabels).length, 'entries');
        return state.familyLabels;
      } else {
        console.warn('Could not load family_labels.json, using existing cache');
        return state.familyLabels || {};
      }
    } catch (error) {
      console.warn('Error loading family labels:', error);
      return state.familyLabels || {};
    }
  }

  // Get label data for a person - FIXED to use correct field names
  async function getPersonData(id) {
    await loadFamilyLabels();
    const data = state.familyLabels[id];
    if (data) {
      return {
        name: data.firstName || '',  // Changed from data.name to data.firstName
        birthDate: data.birthDate || '',
        location: data.location || '',
        notes: data.notes || ''
      };
    }
    
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(`swipetree.meta.${id}`);
      if (stored) {
        const parsed = JSON.parse(stored);
        return {
          name: parsed.name || '',
          birthDate: parsed.dob || '',
          location: '',
          notes: ''
        };
      }
    } catch (e) {
      console.warn('Error reading localStorage:', e);
    }
    
    return { name: '', birthDate: '', location: '', notes: '' };
  }

  // Save label data (saves to localStorage, GitHub sync handled by mobile app)
  function savePersonData(id, data) {
    try {
      localStorage.setItem(`swipetree.meta.${id}`, JSON.stringify({
        name: data.name,
        dob: data.birthDate
      }));
      console.log('Saved to localStorage for ID:', id);
    } catch (e) {
      console.warn('Error saving to localStorage:', e);
    }
  }

  // Display name for a person
  async function displayNameFor(id) {
    const data = await getPersonData(id);
    return data.name || '';
  }

  // Format details display
  function formatDetails(data) {
    const parts = [];
    if (data.birthDate) parts.push(`<span class="date">${data.birthDate}</span>`);
    if (data.location) parts.push(`<span class="location">${data.location}</span>`);
    
    let details = parts.join(' | ');
    if (data.notes) {
      details += `<div class="notes">${data.notes}</div>`;
    }
    
    return details;
  }

  async function tryLoadNamesMap(){
    try{
      const res = await fetch(IMG_BASE + 'names.json' + cacheBust());
      if(res.ok){ 
        const data = await res.json(); 
        if(data && typeof data==='object') state.namesMap=data; 
      }
    } catch {}
  }

  function getIdParts(idStr){ const p=idStr.split('.'); return { baseId:p[0], isSpouse:(p[1]==='1'), partnerHint:(p[2]||null) }; }
  function countTrailingZeros(s){ let c=0; for(let i=s.length-1;i>=0;i--){ if(s[i]!=='0') break; c++; } return c; }
  const toInt = s=>parseInt(s,10);
  function toStr(n,d){ let s=String(n); while(s.length<d) s='0'+s; return s; }

  function parentOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    if(tz<=0) return null; const n=toInt(baseId); const step=Math.pow(10,tz); const parent=n-(n%(step*10)); return toStr(parent,d);
  }
  function childrenOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    const childStep=Math.pow(10, Math.max(0,tz-1)); const floor=toInt(baseId) - (toInt(baseId) % (childStep*10));
    const out=[]; for(let k=1;k<=MAX_CANDIDATES;k++) out.push(toStr(floor+k*childStep,d)); return out;
  }
  function siblingsOf(idStr){
    const {baseId}=getIdParts(idStr); const d=baseId.length; const tz=countTrailingZeros(baseId);
    const sibStep=Math.pow(10,tz); const floor=toInt(baseId) - (toInt(baseId) % (sibStep*10));
    const out=[]; for(let k=1;k<=MAX_CANDIDATES;k++){ const s=toStr(floor+k*sibStep,d); if(s!==baseId) out.push(s); } return out;
  }

  // Enhanced setAnchor with family labels - FIXED to display names and locations
  async function setAnchor(idStr, pushHistory=true){
    if(state.gridOpen) closeGrid();
    if(state.anchorId && pushHistory) state.historyStack.push(state.anchorId);
    state.anchorId=idStr; setURLHash(idStr);
    const src=idToSrc(idStr); const ok=await exists(src);
    anchorImg.src = ok ? src : PLACEHOLDER; // Removed cache busting from display too
    anchorImg.classList.remove('highlight');
    
    // Load and display family data
    const personData = await getPersonData(idStr);
    
    // Display name prominently
    anchorName.textContent = personData.name || '';
    
    // Display location under name (if available)
    let details = '';
    if (personData.location) {
      details = `<span class="location">${personData.location}</span>`;
    }
    if (personData.birthDate) {
      if (details) details += ' | ';
      details += `<span class="date">${personData.birthDate}</span>`;
    }
    anchorDetails.innerHTML = details;
    
    console.log(`Displaying person ${idStr}: "${personData.name}" from "${personData.location}"`);
    
    requestAnimationFrame(()=>{ anchorImg.classList.add('highlight'); setTimeout(()=>anchorImg.classList.remove('highlight'),350); });
  }

  function openGrid(title,cards,kind=null){
    gridTitle.textContent=title; 
    grid.innerHTML=''; 
    grid.classList.remove('parents', 'children'); 
    if(kind==='parents') grid.classList.add('parents');
    if(kind==='children') grid.classList.add('children');
    cards.forEach(c=>{
      const tile=document.createElement('div'); tile.className='tile noselect'; tile.dataset.id=c.id;
      const detailsHtml = c.details ? `<div class="tile-details">${c.details}</div>` : '';
      tile.innerHTML=`<img alt="${c.id}" src="${c.src}"><div class="label">${c.name||''}</div>${detailsHtml}`; // Removed cache busting
      tile.addEventListener('click', async ()=>{ closeGrid(); await setAnchor(c.id); });
      grid.appendChild(tile);
    });
    gridOverlay.classList.remove('hidden'); state.gridOpen=true;
  }
  function closeGrid(){ 
    gridOverlay.classList.add('hidden'); 
    state.gridOpen=false; 
    state.gridType=null; 
    grid.classList.remove('parents', 'children');
  }

  function onTouchStart(e){ 
    if(state.longPressTimer) clearTimeout(state.longPressTimer);
    const t=e.touches?e.touches[0]:e; state.touchStart={x:t.clientX,y:t.clientY,time:Date.now()};
    state.longPressTimer=setTimeout(()=>{ openEdit(); }, LONGPRESS_MS);
  }
  function onTouchMove(e){ 
    if(!state.touchStart) return; 
    const t=e.touches?e.touches[0]:e;
    if(Math.abs(t.clientX-state.touchStart.x)>10||Math.abs(t.clientY-state.touchStart.y)>10) clearTimeout(state.longPressTimer);
  }
  function onTouchEnd(e){ 
    if(state.longPressTimer) clearTimeout(state.longPressTimer); 
    if(!state.touchStart) return;
    const t=e.changedTouches?e.changedTouches[0]:e; 
    const dx=t.clientX-state.touchStart.x, dy=t.clientY-state.touchStart.y;
    const adx=Math.abs(dx), ady=Math.abs(dy); 
    state.touchStart=null; 
    if(adx<40 && ady<40) return;
    if(adx>ady){ if(dx>0) handleSpouseSwipe(); else handleSiblingsSwipe(); } else { if(dy>0) handleChildrenSwipe(); else handleParentsSwipe(); }
  }

  async function existingCards(ids){ 
    // Back to parallel loading like the original working version
    const checks = await Promise.all(ids.map(id => exists(idToSrc(id))));
    const out = [];
    
    for(let i = 0; i < ids.length; i++) {
      if(checks[i]) {
        const personData = await getPersonData(ids[i]);
        const details = personData.location || '';
        out.push({
          id: ids[i], 
          src: idToSrc(ids[i]), 
          name: personData.name,
          details: details
        });
      }
    }
    
    return out; 
  }

  async function handleChildrenSwipe(){ 
    const childIds = childrenOf(state.anchorId);
    const cards = await existingCards(childIds);
    openGrid('Children', cards, 'children'); 
    state.gridType='children'; 
  }
  async function handleSiblingsSwipe(){ openGrid('Siblings', await existingCards(siblingsOf(state.anchorId)), 'siblings'); state.gridType='siblings'; }
  
  async function handleParentsSwipe(){ 
    const p=parentOf(state.anchorId); const cards=[];
    if(p){ 
      await loadSpouseMap();
      
      const ok=await exists(idToSrc(p)); 
      const personData = await getPersonData(p);
      cards.push({
        id: p, 
        src: ok ? idToSrc(p) : PLACEHOLDER, 
        name: personData.name,
        details: personData.location || ''
      });
      
      // Check spouse_link.json first for independent spouse
      const linkedSpouse = state.spouseMap[p];
      if (linkedSpouse && await exists(idToSrc(linkedSpouse))) {
        const linkedSpouseData = await getPersonData(linkedSpouse);
        cards.push({
          id: linkedSpouse, 
          src: idToSrc(linkedSpouse), 
          name: linkedSpouseData.name,
          details: linkedSpouseData.location || ''
        });
      } else {
        // Fall back to .1 spouse and .0 co-parent system
        const spouse = p + '.1';
        const coParent = p + '.0';
        
        const spouseExists = await exists(idToSrc(spouse));
        const coParentExists = await exists(idToSrc(coParent));
        
        if (spouseExists) {
          const spouseData = await getPersonData(spouse);
          cards.push({
            id: spouse, 
            src: idToSrc(spouse), 
            name: spouseData.name,
            details: spouseData.location || ''
          });
        } else if (coParentExists) {
          const coParentData = await getPersonData(coParent);
          cards.push({
            id: coParent, 
            src: idToSrc(coParent), 
            name: `Co-Parent: ${coParentData.name}`,
            details: coParentData.location || ''
          });
        } else {
          cards.push({
            id: 'Parent2', 
            src: PLACEHOLDER, 
            name: '',
            details: ''
          }); 
        }
      }
    }
    openGrid('Parents', cards, 'parents'); state.gridType='parents'; 
  }

  async function handleSpouseSwipe(){ 
    await loadSpouseMap();
    
    // First check: spouse_link.json for independent spouses
    const linkedSpouse = state.spouseMap[state.anchorId];
    if (linkedSpouse && await exists(idToSrc(linkedSpouse))) {
      await setAnchor(linkedSpouse);
      return;
    }
    
    // Second check: .1 suffix system (but skip .0 co-parents)
    const p = getIdParts(state.anchorId); 
    
    // Skip .0 partners - they are co-parents, not spouses
    if (state.anchorId.endsWith('.0')) {
      console.log('Skipping .0 co-parent in spouse navigation');
      return;
    }
    
    const t = p.isSpouse ? p.baseId : p.baseId + '.1'; 
    if (await exists(idToSrc(t))) await setAnchor(t); 
  }

  // Edit overlay
  async function openEdit(){ 
    const id=state.anchorId; 
    const data = await getPersonData(id);
    editName.value = data.name || ''; 
    editDob.value = data.birthDate || '';
    editLocation.value = data.location || '';
    editNotes.value = data.notes || '';
    editOverlay.classList.remove('hidden'); 
    setTimeout(()=>editName.focus(),0); 
  }
  function closeEdit(){ editOverlay.classList.add('hidden'); }
  
  editCancel.addEventListener('click', closeEdit);
  editOverlay.addEventListener('click', (e)=>{ if(e.target===editOverlay) closeEdit(); });
  editSave.addEventListener('click', async ()=>{ 
    const id=state.anchorId; 
    const data = {
      name: editName.value.trim(),
      birthDate: editDob.value.trim(),
      location: editLocation.value.trim(),
      notes: editNotes.value.trim()
    };
    
    savePersonData(id, data);
    
    // Update display immediately
    anchorName.textContent = data.name || '';
    anchorDetails.innerHTML = formatDetails(data);
    closeEdit(); 
  });

  // Navigation button event handlers
  navParents.addEventListener('click', handleParentsSwipe);
  navPartner.addEventListener('click', handleSpouseSwipe);
  navSiblings.addEventListener('click', handleSiblingsSwipe);
  navChildren.addEventListener('click', handleChildrenSwipe);

  // Attach gestures to anchor
  ['touchstart','mousedown'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchStart,{passive:true}));
  ['touchmove','mousemove'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchMove,{passive:true}));
  ['touchend','mouseup','mouseleave'].forEach(ev=>anchorWrap.addEventListener(ev,onTouchEnd,{passive:true}));

  backBtn.addEventListener('click', async ()=>{ 
    if(state.gridOpen){ closeGrid(); return; } 
    const prev=state.historyStack.pop(); 
    if(prev) await setAnchor(prev,false); 
  });

  // Suppress OS context menu
  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('gesturestart', e=>e.preventDefault());
  document.addEventListener('gesturechange', e=>e.preventDefault());
  document.addEventListener('gestureend', e=>e.preventDefault());
  document.addEventListener('touchmove', e=>{ if(state.gridOpen===false) e.preventDefault(); }, {passive:false});

  (async function boot(){ 
    await tryLoadNamesMap(); 
    await loadFamilyLabels(); // Load family labels on startup
    await loadSpouseMap(); // Load spouse links on startup
    let start=decodeURIComponent((location.hash||'').replace(/^#/,'')).trim(); 
    if(!start) start='100000'; 
    await setAnchor(start,false); 
  })();

})();
  </script>
</body>
</html>
